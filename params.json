{
  "name": "aoos",
  "tagline": "Another Object Oriantation System in R",
  "body": "[![Build Status](https://travis-ci.org/wahani/aoos.png?branch=master)](https://travis-ci.org/wahani/aoos)\r\n[![CRAN Version](http://www.r-pkg.org/badges/version/aoos)](http://cran.rstudio.com/web/packages/aoos)\r\n![](http://cranlogs.r-pkg.org/badges/aoos)\r\n[![codecov.io](https://codecov.io/github/wahani/aoos/coverage.svg?branch=master)](https://codecov.io/github/wahani/aoos?branch=master)\r\n\r\n# Another object orientation system in R\r\nAnother implementation of object-orientation in R. It provides syntactic sugar for the S4 class system and two alternative new implementations. One is an experimental version built around S4 and the other one makes it more convenient to work with lists as objects.\r\n\r\n## Installation\r\nTo install from CRAN:\r\n\r\n```r\r\ninstall.packages(\"aoos\")\r\n```\r\n\r\nTo install from this repo:\r\n\r\n```r\r\nlibrary(devtools)\r\ninstall_github(\"wahani/aoos\")\r\n```\r\n\r\n\r\n## Examples:\r\n\r\n### retList:\r\n\r\nBasically you define constructor functions. There is no *formal* class\r\ndefinition. The function body will define what members an object will have. You\r\nquit the function defining the return value using `retList` which is a *generic*\r\nconstructor function. By default it will look at the environment from which it\r\nis called and convert that environment into a list. That list is returned and is\r\nan object. Names with a \".\" are not part of the constructed *list* (by default).\r\n\r\n\r\n```r\r\nlibrary(\"aoos\")\r\nEmployee <- function(.name, .salary) {\r\n  \"Common base class for all employees\"\r\n  \r\n  print <- function(x, ...) {\r\n    cat(\"Name  : \", .self$.name, \"\\nSalary: \", .self$.salary)\r\n  }\r\n  \r\n  getName <- function() .name\r\n  getSalary <- function() .self$.salary\r\n  \r\n  retList(c(\"Employee\", \"Print\"))\r\n  \r\n}\r\n\r\npeter <- Employee(\"Peter\", 5)\r\npeter\r\n```\r\n\r\n```\r\n## Name  :  Peter \r\n## Salary:  5\r\n```\r\n\r\n```r\r\npeter$getName()\r\n```\r\n\r\n```\r\n## [1] \"Peter\"\r\n```\r\n\r\n```r\r\npeter$getSalary()\r\n```\r\n\r\n```\r\n## [1] 5\r\n```\r\n\r\nHere every instance is of class *Employee* and also inherits from class *Print*.\r\nThis enables us to define the print method in the functions body and is\r\nequivalent to invoking the print method directly:\r\n\r\n\r\n```r\r\npeter\r\n```\r\n\r\n```\r\n## Name  :  Peter \r\n## Salary:  5\r\n```\r\n\r\n```r\r\npeter$print()\r\n```\r\n\r\n```\r\n## Name  :  Peter \r\n## Salary:  5\r\n```\r\n\r\n\r\n### retList + Inheritance:\r\n\r\nYou can inherit methods and fields from a super class, or rather an instance,\r\nbecause there is no *formal* class definition. Methods and fields can be\r\nreplaced in the child, all member from the parent are also available for the\r\nmethods of the child.\r\n\r\n\r\n```r\r\nManager <- function(.name, .salary, .bonus) {\r\n  \"Extending the Employee class\"\r\n  \r\n  bonus <- function(x) {\r\n    if (!missing(x)) .self$.bonus <- x\r\n    .self$.bonus\r\n  }\r\n  \r\n  print <- function(x, ...) {\r\n    cat(\"Name  : \", .self$.name, \"\\nSalary: \", .self$.salary, \r\n        \"\\nBonus:\", .self$.bonus)\r\n  }\r\n  \r\n  retList(\"Manager\", super = Employee(.name, .salary))\r\n  \r\n}\r\n\r\njulia <- Manager(\"Julia\", 5, 5 * 1e6)\r\njulia\r\n```\r\n\r\n```\r\n## Name  :  Julia \r\n## Salary:  5 \r\n## Bonus: 5e+06\r\n```\r\n\r\n```r\r\njulia$getSalary()\r\n```\r\n\r\n```\r\n## [1] 5\r\n```\r\n\r\n```r\r\njulia$bonus(10)\r\n```\r\n\r\n```\r\n## [1] 10\r\n```\r\n\r\n```r\r\njulia\r\n```\r\n\r\n```\r\n## Name  :  Julia \r\n## Salary:  5 \r\n## Bonus: 10\r\n```\r\n\r\n### S4 generics\r\n\r\nAs of version 0.3.1 there exist two binary operators, `%g%` and `%m%`, which\r\nlink to the S4 system for generic functions. They provide (hopefully) concise\r\nalternatives to `methods::setGeneric` and `methods::setMethod`:\r\n\r\n\r\n```r\r\n# Standard definition for a generic without default:\r\nnumeric : strLength(x, ...) %g% standardGeneric(\"strLength\")\r\n\r\n# A method for x:character\r\nstrLength(x ~ character, ...) %m% { nchar(x) }\r\n\r\n# Kind of the default method for x:ANY\r\nstrLength(x ~ ANY, ...) %m% { strLength(as.character(x)) }\r\n\r\n# Check that it works:\r\nstrLength(123)\r\n```\r\n\r\n```\r\n## [1] 3\r\n```\r\n\r\n```r\r\nstrLength(\"ab\")\r\n```\r\n\r\n```\r\n## [1] 2\r\n```\r\n\r\nYou may have noticed that we also constrained the return value of any method\r\nbelonging to the generic `strLength` to be a *numeric*. There exist methods\r\nfor objects of type *character* and *ANY* type.\r\n\r\nIn S4, methods can have defaults for arguments which are not formals of the\r\ngeneric. Otherwise the defaults of the generic are passed down to its methods.\r\nThis is not changed: Define defaults for the generic. If a method has more\r\narguments than its generic you can define defaults for them. For the *shared*\r\nargument names provide a class name. One exception to the rule is `...` which\r\ncan have no type. \r\n\r\n### S4 Types\r\n\r\nThe following presents the function `%type%` which is a link to S4s `setClass`. \r\n`%type%` tries to abstract a typical scenario of using `setClass`. \r\n\r\nIn the following We define two types. One is *Test* which has two fields, *x*\r\nand *y*. *x* is of type *numeric*, *y* is a *list*. Notice that you can either\r\ndefine a prototype (a default) for a field (for which the class is inferred), or\r\nyou state the class explicitly using `~`.\r\n\r\nThe second is *Child* and inherits the properties from *Test*. Thus it has\r\nalso two fields, *x* and *y*, and in addition we say it inherits from type\r\n*character*. So *Child* is basically a character vector with two attributes:\r\n\r\n\r\n```r\r\nTest(x ~ numeric, y = list()) %type% {\r\n  stopifnot(length(.Object@x) == 1)\r\n  stopifnot(.Object@x > 0)\r\n  .Object\r\n}\r\n\r\nTest : character : Child() %type% .Object\r\n\r\nTest(2)\r\n```\r\n\r\n```\r\n## An object of class \"Test\"\r\n## Slot \"x\":\r\n## [1] 2\r\n## \r\n## Slot \"y\":\r\n## list()\r\n```\r\n\r\n```r\r\nChild(\"Hej\", x = 2)\r\n```\r\n\r\n```\r\n## An object of class \"Child\"\r\n## [1] \"Hej\"\r\n## Slot \"x\":\r\n## [1] 2\r\n## \r\n## Slot \"y\":\r\n## list()\r\n```\r\n\r\nNotice that the right hand side of the expression is more or less the definition\r\nof the initialization method for a type. Arbitrary operations can be made during \r\ninit, in the above example we formulate some assertions (x > 0 and scalar). The\r\ninit method for type *Child* just returns the object itself named `.Object`\r\n(see the help page for `methods::initialize` to understand the naming).\r\n\r\n### S4 Type Unions\r\n\r\nS4 provides also the possibility to construct type unions which are useful to\r\nallow a type to inherit from different types at the same time, e.g. a type which\r\ncan either be a *numeric* or *character*. This feature is not yet complete, but\r\nhere are some ways you can use it. For the definition of a type:\r\n\r\n\r\n```r\r\n'numeric | character' : Either() %type% .Object\r\nEither(1)\r\n```\r\n\r\n```\r\n## An object of class \"Either\"\r\n## [1] 1\r\n```\r\n\r\n```r\r\nEither(\"Hello World!\")\r\n```\r\n\r\n```\r\n## An object of class \"Either\"\r\n## [1] \"Hello World!\"\r\n```\r\n\r\nIn the definition of a field:\r\n\r\n\r\n```r\r\nEither(x ~ numeric | character) %type% .Object\r\nEither(1)\r\n```\r\n\r\n```\r\n## An object of class \"Either\"\r\n## Slot \"x\":\r\n## [1] 1\r\n```\r\n\r\n```r\r\nEither(\"Hello World!\")\r\n```\r\n\r\n```\r\n## An object of class \"Either\"\r\n## Slot \"x\":\r\n## [1] \"Hello World!\"\r\n```\r\n\r\nIn the definition of a generic or method:\r\n\r\n\r\n```r\r\n'numeric | character' : complicatedFunction(x = 1) %g% as.character(x)\r\ncomplicatedFunction(x ~ character | integer) %m% as.numeric(x)\r\ncomplicatedFunction()\r\n```\r\n\r\n```\r\n## [1] \"1\"\r\n```\r\n\r\n```r\r\ncomplicatedFunction(\"1\")\r\n```\r\n\r\n```\r\n## [1] 1\r\n```\r\n\r\n```r\r\ncomplicatedFunction(1L)\r\n```\r\n\r\n```\r\n## [1] 1\r\n```\r\n\r\n### Polymorphic Methods in Objects\r\n\r\nIn contrast to the defaults in S4, `%g%` and `%m%` have side effects in the\r\nenvironment they are called in. That means you can define generics which are \r\nlocal to a function or closure. Nice all by itself but it also extends the\r\n`retList`-idea of representing objects in *R* as demonstrated here:\r\n\r\n\r\n```r\r\nClass <- function() {\r\n  \r\n  overloaded(x) %g% { \r\n    cat(\"This is the default ... \\n\")\r\n    x \r\n  } \r\n  \r\n  overloaded(x ~ numeric) %m% {\r\n    cat(\"This is the method for 'numeric' values ... \\n\")\r\n    x\r\n  }\r\n  \r\n  retList(\"Class\")\r\n}\r\n\r\ninstance <- Class()\r\ninstance$overloaded(1)\r\n```\r\n\r\n```\r\n## This is the method for 'numeric' values ...\r\n```\r\n\r\n```\r\n## [1] 1\r\n```\r\n\r\n```r\r\ninstance$overloaded(\"a\")\r\n```\r\n\r\n```\r\n## This is the default ...\r\n```\r\n\r\n```\r\n## [1] \"a\"\r\n```\r\n\r\nThe next question is how to inherit or extend an existing generic which is a\r\nmember of a class? I am not entirely happy with how this works at the moment,\r\nbut this is one way to approach it (which works...):\r\n\r\n\r\n```r\r\nChild <- function() {\r\n  \r\n  # Normally you would make the call to the parents constructor in the call\r\n  # to retList. But here we need to access the elements directly during init...\r\n  .super <- Class()\r\n  \r\n  # This points %m% to the generic (in .super) which should be extended:\r\n  .super$overloaded(x ~ integer) %m% {\r\n    cat(\"This is the method for 'integer' values ... \\n\")\r\n    x\r\n  }\r\n  \r\n  retList(\"Child\", super = .super)\r\n  \r\n}\r\n\r\ninstance <- Child()\r\ninstance$overloaded(1)\r\n```\r\n\r\n```\r\n## This is the method for 'numeric' values ...\r\n```\r\n\r\n```\r\n## [1] 1\r\n```\r\n\r\n```r\r\ninstance$overloaded(\"a\")\r\n```\r\n\r\n```\r\n## This is the default ...\r\n```\r\n\r\n```\r\n## [1] \"a\"\r\n```\r\n\r\n```r\r\ninstance$overloaded(1L)\r\n```\r\n\r\n```\r\n## This is the method for 'integer' values ...\r\n```\r\n\r\n```\r\n## [1] 1\r\n```\r\n\r\n### More unsorted ideas\r\n\r\n#### Public Fields\r\n\r\nSomething you have to keep in mind is that returned objects are of class *list*.\r\nIf you want to have a public field you have to define get and set methods,\r\nbecause you will see a copy of those fields in the object, they behave more like\r\nan attribute.\r\n\r\n\r\n```r\r\nObjectWithField <- function(name) {\r\n  getName <- function() {\r\n    name\r\n  }\r\n  retList()\r\n} \r\n\r\nobj <- ObjectWithField(\"Alexander\")\r\nobj$name <- \"Noah\"\r\nobj$getName()\r\n```\r\n\r\n```\r\n## [1] \"Alexander\"\r\n```\r\n\r\n```r\r\nobj$name\r\n```\r\n\r\n```\r\n## [1] \"Noah\"\r\n```\r\n\r\nWe can do more abstract representations of *things*. In this example I want to\r\ncreate a constructor object which keeps track of how many instances it created.\r\nAlso every instance should know how many siblings it has, or in other words all\r\ninstances share a reference to a field accessible by all of them.\r\n\r\n\r\n```r\r\ninitFamily <- function(.familyName) {\r\n  \r\n  .superEnv <- environment()\r\n  .count <- 0\r\n  \r\n  getCount <- function() {\r\n    cat(\"There are\", .self$.count, paste0(.familyName, \"s\"), \"out there.\")\r\n  }\r\n  \r\n  new <- function(.name) {\r\n    # happens on init\r\n    .count <<- .count + 1\r\n    \r\n    print <- function(x, ...) cat(\"My name is\", .self$.name, .familyName, \"!\")\r\n    countSiblings <- function() cat(\"I have\", .count, \"siblings!\")\r\n    \r\n    # So every instance knows about .count and .familyName:\r\n    retList(c(\"Person\", \"Print\"), superEnv = new.env(parent = .superEnv))\r\n  }\r\n  \r\n  retList(\"ConstructorPerson\")\r\n  \r\n}\r\n\r\nschmidt <- initFamily(\"Schmidt\")\r\nschmidt$getCount()\r\n```\r\n\r\n```\r\n## There are 0 Schmidts out there.\r\n```\r\n\r\n```r\r\nlisa <- schmidt$new(\"Lisa\")\r\n\r\nsandra <- schmidt$new(\"Sandra\")\r\nschmidt$getCount()\r\n```\r\n\r\n```\r\n## There are 2 Schmidts out there.\r\n```\r\n\r\n```r\r\nsandra$countSiblings()\r\n```\r\n\r\n```\r\n## I have 2 siblings!\r\n```\r\n\r\n```r\r\nsandra\r\n```\r\n\r\n```\r\n## My name is Sandra Schmidt !\r\n```\r\n\r\n```r\r\nlisa\r\n```\r\n\r\n```\r\n## My name is Lisa Schmidt !\r\n```\r\n\r\n#### Self-contained Method Invocation\r\n\r\nThese ideas can be combined to construct something object like in S4 with fields\r\nas slots and methods contained in a list (other patterns can be thought of...):\r\n\r\n\r\n```r\r\n# Some extra stuff to make the instance on which a method is invoked available\r\n# during the call.\r\nsetClass(\"Self\", contains = \"VIRTUAL\")\r\n\r\nsetMethod(\"$\", \"Self\", function(x, name) {\r\n  function(...) x[[name]](.Object = x, ...)\r\n})\r\n```\r\n\r\n```\r\n## [1] \"$\"\r\n```\r\n\r\n```r\r\nSelf : Show : Test : list : Super() %type% {\r\n  method <- function(.Object) .Object@x * 2\r\n  show <- function(.Object) cat(\"Value for x:\", .Object@x)\r\n  S3Part(.Object) <- retList(super = .Object)\r\n  .Object\r\n}\r\n\r\nx <- Super(x = 2)\r\nx\r\n```\r\n\r\n```\r\n## Value for x: 2\r\n```\r\n\r\n```r\r\nx$method()\r\n```\r\n\r\n```\r\n## [1] 4\r\n```\r\n\r\nAnd for the S3 retList thing:\r\n\r\n\r\n```r\r\n\"$.Self\" <- function(x, name) {\r\n  callIsLocal <- any(sapply(aoos:::envirSearch(list(parent.frame())), \r\n                            identical, y = attr(x, \".self\")))\r\n  if (callIsLocal) {\r\n    obj <- attr(x, \".self\")[[name]]\r\n    if (inherits(obj, \"function\")) function(...) obj(self = x, ...)\r\n    else obj\r\n  }\r\n  else function(...) x[[name]](self = x, ...)\r\n}\r\n\r\n\"$<-.Self\" <- function(x, name, value) {\r\n  callIsLocal <- any(sapply(aoos:::envirSearch(list(parent.frame())), \r\n                            identical, y = attr(x, \".self\")))\r\n  \r\n  if (callIsLocal) {\r\n    assign(name, value = value, envir = attr(x, \".self\"))\r\n  } else {\r\n    stop(\"This method has been disabled for objects of class 'Self'.\")\r\n  }\r\n  \r\n  x\r\n}\r\n\r\nSelf <- function(.x) {\r\n  \r\n  setX <- function(self, val) {\r\n    self$.x <- val \r\n    invisible(self)\r\n  }\r\n  \r\n  getX <- function(self) {\r\n    self$.x\r\n  }\r\n  \r\n  retList(c(\"Self\"))\r\n\r\n}\r\n\r\ninst <- Self(2)\r\ninst$setX(3)$setX(4)\r\ninst$getX()\r\n```\r\n\r\n```\r\n## [1] 4\r\n```\r\n\r\n```r\r\ninst$.x <- 2\r\n```\r\n\r\n```\r\n## Error in `$<-.Self`(`*tmp*`, \".x\", value = 2): This method has been disabled for objects of class 'Self'.\r\n```\r\n\r\n#### Syntactic Sugar for Return List\r\n\r\n\r\n```r\r\nPerson <- function(.name) {\r\n  \r\n  print <- function(x, ...) {\r\n    cat(paste0(\"Hello, my name is \", .name, \".\\n\"))\r\n  }\r\n  \r\n  retList(c(\"Person\", \"Print\"))\r\n  \r\n}\r\n\r\nEmployee <- function(.id, ...) {\r\n  \r\n  print <- function(x, ...) {\r\n    cat(\"Name: \", .name, \"\\nID:   \", .id)\r\n  }\r\n  \r\n  retList(\"Employee\") %inherit% Person(...)\r\n  \r\n}\r\n\r\n\"%inherit%\" <- function(child, parent) {\r\n  retList(class(child), names(child), super = parent, mergeFun = envCopy, list2env(child))\r\n}\r\n\r\nkalle <- Employee(\"1\", \"Kalle\")\r\nstr(kalle)\r\n```\r\n\r\n```\r\n## List of 1\r\n##  $ print:function (x, ...)  \r\n##   ..- attr(*, \"srcref\")=Class 'srcref'  atomic [1:8] 13 12 15 3 12 3 13 15\r\n##   .. .. ..- attr(*, \"srcfile\")=Classes 'srcfilecopy', 'srcfile' <environment: 0x6c68c20> \r\n##  - attr(*, \".self\")=<environment: 0x668d730> \r\n##  - attr(*, \"class\")= chr [1:5] \"Employee\" \"list\" \"Person\" \"Print\" ...\r\n```\r\n\r\n```r\r\nclass(kalle)\r\n```\r\n\r\n```\r\n## [1] \"Employee\" \"list\"     \"Person\"   \"Print\"    \"list\"\r\n```\r\n\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}