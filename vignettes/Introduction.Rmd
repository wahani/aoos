---
title: "Introduction"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Introduction}
  %\VignetteEngine{knitr::rmarkdown}
  %\usepackage[utf8]{inputenc}
---

This package implements two ways to define reference classes inside the R language. The original implementation was the function `defineClass` and an introduction to this implementation can be found here:

```{r, eval=FALSE}
vignette("aoosClasses", "aoos")
```

`defineClass` is an own implementation of object orientation, like `setRefClass` it uses S4, and can be considered experimental, although it has been reliable in my own work. My current recommendation, however, is to use the function `Class`, which does not implement a new logic of object orientation but fixes my major critique of `setRefClass`: defining methods and fields inside lists. It is simply a wrapper which allows to write the class definition inside an R-expression, very much like in `defineClass`, the results are then passed as arguments to `setRefClass`. The following example is taken from the documentation file of `setRefClass` to have a direct comparison so you can decide if this is an actual improvement in readability. To the best of my knowledge using `Class` instead of `setRefClass` only changes the appearance, all features are preserved and the outcome is identical to using `setRefClass`.

```{r}
mEdit <- Class({
  Class <- "mEdit"
  
  data <- "matrix"
  edits <- "list"

  edit <- function(i, j, value) {
    ## the following string documents the edit method
    'Replaces the range [i, j] of the object by value.'
    backup <- list(i, j, data[i,j])
    data[i,j] <<- value
    edits <<- c(edits, list(backup))
    invisible(value)
  }

  undo <- function() {
    'Undoes the last edit() operation and update the edits field accordingly.'
    prev <- edits
    if(length(prev)) prev <- prev[[length(prev)]]
    else stop("No more edits to undo")
    edit(prev[[1]], prev[[2]], prev[[3]])
    ## trim the edits list
    length(edits) <<- length(edits) - 2
    invisible(prev)
  }
  
  show <- function() {
    'Method for automatically printing matrix editors' 
    cat("Reference matrix editor object of class", 
        classLabel(class(.self)), "\n")
    cat("Data: \n")
    methods::show(data)
    cat("Undo list is of length", length(edits), "\n")
  }
})

xMat <- matrix(1:12,4,3)
xx <- mEdit(data = xMat)
xx$edit(2, 2, 0)
xx
xx$undo()
mEdit$help("undo")
stopifnot(all.equal(xx$data, xMat))

utils::str(xx) # show fields and names of non-trivial methods

## add a method to save the object
mEdit$methods(
  save = function(file) {
    'Save the current object on the file in R external object format.'
         base::save(.self, file = file)
     }
)

tf <- tempfile()
xx$save(tf)

# mv <- Class({
#   Class <- "matrixViewer"
#   contains <- "mEdit"
#   
#   viewerDevice <- viewerFile <- "ANY"
#   
#   view <- function() {
#     dd <- dev.cur(); dev.set(viewerDevice)
#     devAskNewPage(FALSE)
#     matplot(data, main = paste("After",length(edits),"edits"))
#     dev.set(dd)
#   }
#   
#   edit <- function(i, j, value) {
#     callSuper(i, j, value)
#     view()
#   }
# })
# 
# mv$methods(
#   initialize =
#     function(file = "./matrixView.pdf", ...) {
#       viewerFile <<- file
#       pdf(viewerFile)
#       viewerDevice <<- dev.cur()
#       dev.set(dev.prev())
#       callSuper(...)
#     },
#   finalize = function() {
#     dev.off(viewerDevice)
#   })

```

