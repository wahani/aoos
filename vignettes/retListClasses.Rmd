---
title: "retListClasses"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{retListClasses}
  %\VignetteEngine{knitr::rmarkdown}
  %\usepackage[utf8]{inputenc}
---

## retList classes

`retList` can be used as a shortcut to:

```{r eval=FALSE}
constructor <- function(...) {
  ...
  out <- list(...)
  class(out) <- "constructor"
  out
}
```

vs. 

```{r eval=FALSE}
constructor <- function(...) {
  ...
  retList("constructor")
}
```

It will simply find all objects in the environment in which it is called and returns those in a list. This is one way to think about and implement features associated with object orientation in *R*.

## Basics

Every value bound to a symbol will be public, objects with a leading dot in the name will be private. This can be changed by stating which names to make public explicitely. 

Here is a simple class definition: 

```{r}
library(aoos)

Person <- function(name) {
  
  print <- function() {
    cat(paste0("Hello, my name is ", .self$name, ".\n"))
  }
  
  retList(c("Person", "Print"))
}
```

`retList` is used as a generic constructor function. It allways returns a list containing all visible values from the environment where it is called. There is a print method `print.Print` in the package which will look for a member function called print for printing. Hence the `print` method in the class *Person* will be used as *S3* printing method.

```{r}
ann <- Person("Ann")
ann
```

Inside the class definition you can use `.self` but you do not have to; It just might be more explicit. You can also use the super-assignment operator `<<-`.

You should keep in mind that a public field is a value in a list and not a reference to `.self`. Thus if your object should have public fields you have to define get/set methods. In this example you can think of `name` as an attribute since changing it in an instance won't change the bahavior of `greet`. Here is something you can do instead:

```{r}
Person <- function(.name) {
  
  print <- function(...) {
    cat(paste0("Hello, my name is ", .self$.name, ".\n"))
  }
  
  name <- function(x) {
    if (!missing(x)) .name <<- x
    .name
  }
  
  retList(c("Person", "Print"))
}

p <- Person("Ann")
p
p$name()
p$name("Paul")
p
```

Although I don't understand why 'Ann' can change to be 'Paul', this is one way of adding something like reference semantics.

## Inheritance

Basically you can define how inheritance works. The easiest way is to supply a call to the super classes constructor function, where you also have to supply arguments for initialization.

```{r}
Queue <- function(...) {
  
  .queue <- list(...)
  
  add <- function(x) {
    .queue <<- c(.queue, list(x))
    x
  }
  
  remove <- function() {
    if (queueIsEmpty()) return(NULL)
    head <- .queue[[1]]
    .queue <<- .queue[-1]
    head
  }
  
  queueIsEmpty <- function() length(.queue) == 0
  
  retList("Queue")
  
}

HistoryQueue <- function(...) {
  
  .head_idx <- 0
  
  remove <- function() {
    if ((length(.queue) - .head_idx) == 0) return(NULL)
    .head_idx <<- .head_idx + 1
    .queue[[.head_idx]]
    }
  
  print <- function(...) {
      cat("Next item is at index", .head_idx + 1, "\n")
      for (i in seq_along(.queue)) {
        cat(i, ": ", .queue[[i]], "\n", sep = "")
      }
  }
  
  retList(c("HistoryQueue", "Print"), super = Queue(...))
}

q <- Queue(5, 6, "foo")
q$remove()

hq <- HistoryQueue(5, 6, "foo")
hq
hq$remove()
hq
hq$remove()
hq
```

